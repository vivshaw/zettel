---
tags: courses, Ruby, Rails
---

- # Introduction
  collapsed:: true
	- this course is about leaning into the leverage provided by simple-but-powerful tools like Rails and SQLite
	- this includes not just local dev, but production deployment
	- Rails being an old framework is a good thing, not a bad thing. it means that every edge has been explored in depth.
	- why [[SQLite]]? because it's simple and fast. it's just a file on disk, and it gets embedded in the app's running process. few moving parts, not much to break or slow down.
	- the combination of Rails and SQLite make them a super high-leverage pair for single developers who would like to build ambitious things fast
- # Powering your app with SQLite
	- ## Creating tables
		- [[ActiveRecord]] uses a `schema_migrations` table to track which migrations have happened and which are pending
		- in SQLite, an integer primary key can be an alias for the row ID, which already exists. that saves a little space
			- an autoincrementing key will not reuse any IDs from deleted rows. each ID can be used only once
	- ## Timestamps
		- ActiveRecord automagically adds `created_at` and `updated_at` timestamps to ActiveRecord objects
		- these are stored as ISO 8601 format. SQLite doesn't have a native date/time format. it does support datetime functions that play nice with ISO 8601 text.
	- ## Column types
		- ActiveRecord has 11 column types:
			- `t.binary`
			- `t.boolean`
			- `t.string` small bit of text. think, a tweet
			- `t.text` anything bigger than a string
			- `t.integer`
			- `t.float` - low-precision [[floating point]]
			- `t.decimal` - high-precision [[floating point]]. this will get you deterministic results for basic arithmetic
			- `t.date`
			- `t.time`
			- `t.datetime`
			- `t.json`
		- but SQLite only has 4 main storage classes. how do they get stored, then?
			- `blob`: `t.binary`
			- `integer`: `t.boolean`, `t.integer`
			- `text`: `t.string`, `t.text`, `t.date`, `t.time`, `t.datetime`, `t.json`
			- `real`: `t.float`, `t.decimal`
	- ## Typeof
		- we can use the SQLite `typeof` function to see how our data is being stored
	- ## Ruby types
		- `t.binary` -> `String`
		- `t.boolean` -> `TrueClass` / `FalseClass`
		- `t.string` -> `String`
		- `t.text` -> `String`
		- `t.integer` -> `Integer`
		- `t.float` -> `Float`
		- `t.decimal` -> `BigDecimal`
		- `t.date` -> `Date`
		- `t.date` -> `Time`
		- `t.datetime` -> `Time`
			- in Ruby, there isn't any way to store only a clock value, without a corresponding day!
		- `t.json` -> `Hash`
	- ## Creating tables
		- Rails will use prepared statements for your inserts. this has both performance benefits and security benefits- harder to do [[SQL injection]]
			- ```
			  INSERT INTO table_name (column_1, column_2) VALUES (?, ?)
			  ```
		- Rails will also wrap your ActiveRecord operations in transactions, to prevent data integrity problems
		- `create` and `save` will ensure that all your validations are met before running the SQL query, then run any callbacks you have defined after the query
	- ## Inserting records
		- similar to creating, but:
			- you pass `insert` your values as a hash, then they get inlined into the query instead of done as a prepared statement.
			- you get an ActiveRecord::Result back instead of your item
			- it skips your validation and callbacks
			- it's not wrapped in a transaction
		- `insert_all` will let you insert a batch of records in one go
	- ## Updating data
		- `update!` will throw if validations fail, `update` will return `false` and let you handle manually
		- `update_columns` will skip validations and callbacks, similar to `insert`
		- `save` can be called directly on an existing record instance. there's ` !` and non-`!` version as with `update`